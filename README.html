<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Introduction to Functional Programming</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="introduction-to-functional-programming">Introduction to Functional Programming</h1>
<h2 id="contents">Contents</h2>
<p>TODO</p>
<h2 id="what-is-functional-programming">What is Functional Programming?</h2>
<p>Functional Programming (FP) is a programming paradigm that orients itself around functions and function composition. It is <em>not</em> bound by language necessarily, though certain languages accommodate it more easily than others.</p>
<h3 id="imperative-vs-declarative-functional-vs-object-oriented">Imperative vs Declarative, Functional vs Object Oriented</h3>
<p>You might already be familiar with the Object Oriented Programming paradigm. This is an example of an imperative programming paradigm, which means: a statement-based programming paradigm, where the programmer uses statements to change a program's state. Functional Programming, on the other hand, is a declarative programming paradigm. This means: the programmer declares <em>what</em> a program should do, rather than <em>how</em> it should do this. In functional programming, this is done by declaring functions and composing them.</p>
<p>This leads to an important distinction between FP and OOP: FP is, in most cases, stateless, whereas OOP is not. This is important to realise because it affects the way in which you reason about your code.</p>
<h3 id="examples-of-imperative-vs-functional-style">Examples of imperative vs functional style</h3>
<p><strong>Example: getting the lengths of strings in an array</strong></p>
<pre><code class="language-csharp"><div><span class="hljs-comment">// Imperative</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">LengthGetter</span> {
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">StringLengths</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] input</span>)</span> {
    <span class="hljs-keyword">int</span>[] lengths = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[input.Length];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; input.Length; i++) {
      lengths[i] = input[i].Length;
    }

    <span class="hljs-keyword">return</span> lengths;
  }
}
</div></code></pre>
<pre><code class="language-haskell"><div><span class="hljs-meta"># Functional</span>

<span class="hljs-title">stringLengths</span> :: [<span class="hljs-type">String</span>] -&gt; [<span class="hljs-type">Int</span>]
<span class="hljs-title">stringLengths</span> strs = map length strs
</div></code></pre>
<p><strong>Functional style in C#: using Linq!</strong></p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">using</span> System.Linq;

<span class="hljs-keyword">class</span> <span class="hljs-title">LengthGetter</span> {
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] <span class="hljs-title">StringLengths_Func</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] input</span>)</span> {
    <span class="hljs-keyword">return</span> input.Select(str =&gt; str.Length).ToArray();
  }
}
</div></code></pre>
<h2 id="functional-programming-an-overview">Functional Programming: an overview</h2>
<h3 id="principles-of-fp">Principles of FP</h3>
<p>Four important principles of FP are:</p>
<ul>
<li>Functions as first-class citizens</li>
<li>Function purity</li>
<li>Referential Transparency</li>
<li>Recursion</li>
</ul>
<p><strong>Functions as first-class citizens</strong></p>
<p>Functions should be treated as primary components of a program. They should be transferrable throughout the program like any other type is. This enables another principle of Functional Programming: higher-order functions. Higher order functions are functions that either take in another function as its input, or return another function as their output. Once such higher-order function was already mentioned previously: the function <code>map</code> shown in the imperative vs functional style examples.</p>
<p><strong>Function purity</strong></p>
<p>In imperative languages, a function can produce two outputs: returned values and side effects. Side effects include things like state mutation. Functional programming is, in principle, stateless. Because there is no state, it can also not be mutated.</p>
<p>Some examples of the difference can be seen in the C# code below.</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> counter;

  <span class="hljs-comment"><span class="hljs-doctag">///</span> This function is pure.</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Pure</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> num</span>)</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;
  }

  <span class="hljs-comment"><span class="hljs-doctag">///</span> This function is not pure because it changes the value of this.counter.</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NotPure</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> num</span>)</span> {
    <span class="hljs-keyword">this</span>.counter++;
    <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;
  }

  <span class="hljs-comment"><span class="hljs-doctag">///</span> This function is not pure because its result is dependent on the state (this.counter).</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NotPure2</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> num</span>)</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-keyword">this</span>.counter;
  }
}
</div></code></pre>
<p><strong>Referential Transparency</strong></p>
<p>A result of function purity is referential transparency. The principle of referential transparency describes that for all expressions in the program, if they are replaced with their corresponding results, this does not change the program's behaviour. As long as your functions are pure, this should be the case.</p>
<p><strong>Recursion</strong></p>
<p>Recursion describes the principle of defining methods in terms of themselves. In a lot of Functional Programming languages, recursion is the primary way of doing iteration. Recursive functions consist of two components: one or more recursive cases and one or more base cases, as demonstrated below.</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> {
  <span class="hljs-comment"><span class="hljs-doctag">///</span> This function is recursive.</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">SumUpTo</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> num</span>)</span> {
    <span class="hljs-comment">// For demonstration purposes, we assume num &gt;= 0</span>
    
    <span class="hljs-comment">// The base case</span>
    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) { 
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// The recursive case</span>
    <span class="hljs-keyword">return</span> num + SumUpTo(num - <span class="hljs-number">1</span>);
  }
}
</div></code></pre>
<h3 id="fp-and-code-quality-reasoning-about-your-code">FP and Code Quality: reasoning about your code</h3>
<h3 id="functional-language-features">Functional language features</h3>
<h2 id="functional-programming-in-practice">Functional Programming in Practice</h2>
<h3 id="haskell">Haskell</h3>
<h3 id="c--f">C# &amp; F#</h3>
<h3 id="javascript">JavaScript</h3>
<h2 id="recommended-reading">Recommended reading</h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tour">Microsoft's Tour of F#</a></li>
<li><a href="https://www.bol.com/nl/p/programming-in-haskell/9200000061967819/">Programming in Haskell</a></li>
</ul>

    </body>
    </html>